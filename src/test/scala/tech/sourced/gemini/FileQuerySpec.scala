package tech.sourced.gemini

import java.io.File
import java.nio.file.Files

import gopkg.in.bblfsh.sdk.v1.protocol.generated.ProtocolServiceGrpc.ProtocolService
import gopkg.in.bblfsh.sdk.v1.protocol.generated._
import gopkg.in.bblfsh.sdk.v1.uast.generated.Node
import io.grpc.{ManagedChannelBuilder, ServerBuilder}
import org.apache.spark.internal.Logging
import org.bblfsh.client.BblfshClient
import org.scalatest.{BeforeAndAfterAll, FlatSpec, Matchers}
import tags.DB
import tech.sourced.featurext.generated.service.FeatureExtractorGrpc.FeatureExtractor
import tech.sourced.featurext.generated.service._
import tech.sourced.gemini.util.Logger

import scala.concurrent.{ExecutionContext, Future}
import scala.util.parsing.json.JSON

@tags.DB
class FileQuerySpec extends FlatSpec
  with Matchers
  with BaseDBSpec
  with Logging
  with BeforeAndAfterAll {

  val logger = Logger("gemini")

  keyspace = "fileQuerySpec"

  val duplicateFile = RepoFile(
    "github.com/src-d/borges.git",
    "commit-id",
    "consumer.go",
    "9f653118e787febce824759bb5c4ef17fe4da7b0")
  val similarFile = RepoFile(
    "github.com/erizocosmico/borges.git",
    "commit-id",
    "consumer.go",
    "e32d54ae4b969ac13f737efaf1c11ccfc52bbe5b")
  var licenceFile = RepoFile(
    "null/Users/alex/src-d/gemini",
    "4aa29ac236c55ebbfbef149fef7054d25832717f",
    "LICENSE",
    "097f4a292c384e002c5b5ce8e15d746849af7b37"
  )

  override def beforeAll(): Unit = {
    super.beforeAll()

    val hashtables = readHashItemsFromFile("src/test/resources/hashtables.json")
    insertHashtables(hashtables)
    insertMeta(Array(duplicateFile, similarFile, licenceFile))
  }

  "Read from Database" should "return same results as written" in {
    val gemini = Gemini(null, logger, keyspace)
    val bblfshClient = BblfshClient.apply(Gemini.defaultBblfshHost, Gemini.defaultBblfshPort)
    val channel = ManagedChannelBuilder
      .forAddress(Gemini.defaultFeHost, Gemini.defaultFePort)
      .usePlaintext(true)
      .build()
    val feClient = FeatureExtractorGrpc.stub(channel)

    val QueryResult(duplicates, _) = gemini.query("src/test/resources/LICENSE", cassandra, bblfshClient, feClient)

    duplicates should not be empty
    duplicates.head.sha should be("097f4a292c384e002c5b5ce8e15d746849af7b37") // git hash-object -w LICENSE
    duplicates.head.repo should be("null/Users/alex/src-d/gemini")
    duplicates.head.commit should be("4aa29ac236c55ebbfbef149fef7054d25832717f")
  }

  /**
    * Unit test without any dependencies beside cassandra
    * - it loads .json fixtures to hashtables table for 2 hashed files:
    *     one of which is src/test/resources/consumer.go
    *     one is similar to src/test/resources/consumer.go
    * - it fills meta table with those 2 files
    * - it uses mocks for FE and Bblfsh
    * - feature extractor mock always return features, extracted for this file
    * - docfreq.json generated by hash with default params for siva files in src/test/resources/duplicate-files
    *
    * DB fixture created manually by getting values from DB filled by hash
    * to generate new fixture for features extractors - just dump response of service to json
    * there is no fixture for bblfsh because we do nothing with UAST beside passing it to feature extractor
    */
  var queryResult : QueryResult = _
  "Query for similar files" should "return results" in {
    val features = readFeaturesFromFile("src/test/resources/features.json")

    val server = ServerBuilder
      .forPort(0)
      .addService(ProtocolServiceGrpc.bindService(bblfshMock(new Node), ExecutionContext.global))
      .addService(FeatureExtractorGrpc.bindService(feMock(features), ExecutionContext.global))
      .build
      .start()

    val channel = ManagedChannelBuilder.forAddress("localhost", server.getPort).usePlaintext(true).build()
    val bblfshStub = BblfshClient("localhost", server.getPort)
    val feStub = FeatureExtractorGrpc.stub(channel)

    // full duplicate
    val dupFile = new File("src/test/resources/consumer.go")
    val fileQuery = new FileQuery(
      cassandra,
      bblfshStub,
      feStub,
      "src/test/resources/docfreq.json",
      log,
      keyspace,
      Gemini.tables)

    queryResult = fileQuery.find(dupFile)

    server.shutdown()
  }

  it should "return duplicates" in {
    val QueryResult(duplicates, _) = queryResult

    duplicates.size shouldEqual 1
    duplicates.last shouldEqual duplicateFile
  }

  it should "return similar files" in {
    val QueryResult(_, similar) = queryResult

    similar.size shouldEqual 1
    similar.last shouldEqual similarFile
  }

  // If we would need this mock somewhere else better to move them in traits

  def readFeaturesFromFile(path: String): Seq[Feature] = {
    val file = new File(path)
    val byteArray = Files.readAllBytes(file.toPath)
    val jsonData = JSON.parseFull(new String(byteArray))

    jsonData match {
      case Some(m: Map[_, _]) => {
        val featuresMap = m.asInstanceOf[Map[String, Double]]
        val iter = featuresMap.map { case(key, value) =>
          Feature(name = key, weight = value.toInt)
        }
        iter.toSeq
      }
      case _ => throw new Exception("incorrect json")
    }
  }

  def bblfshMock(uast: Node): ProtocolService = {
    class BblfshServerMock extends ProtocolService {
      override def parse(request: ParseRequest): Future[ParseResponse] = {
        Future.successful(ParseResponse(uast = Some(uast)))
      }

      override def nativeParse(request: NativeParseRequest): Future[NativeParseResponse] = {
        Future.successful(NativeParseResponse())
      }

      override def version(request: VersionRequest): Future[VersionResponse] = {
        Future.successful(VersionResponse())
      }
    }

    new BblfshServerMock
  }

  def feMock(features: Seq[Feature]): FeatureExtractor = {
    class FEServerMock extends FeatureExtractor {
      override def identifiers(request: IdentifiersRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply(features=features))
      }

      override def literals(request: LiteralsRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }

      override def uast2Seq(request: Uast2seqRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }

      override def graphlet(request: GraphletRequest): Future[FeaturesReply] = {
        Future.successful(FeaturesReply())
      }
    }

    new FEServerMock
  }

  def readHashItemsFromFile(path: String): Iterable[HashtableItem] = {
    val file = new File(path)
    val byteArray = Files.readAllBytes(file.toPath)
    val jsonData = JSON.parseFull(new String(byteArray))

    jsonData match {
      case Some(m: List[_]) => {
        m.map { l =>
          val r = l.asInstanceOf[List[String]]
          HashtableItem(hashtable=r(0).toInt, v=r(1), sha1=r(2))
        }
      }
      case _ => throw new Exception("incorrect json")
    }
  }
}
